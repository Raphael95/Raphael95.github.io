<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://raphael95.github.io/output</id>
    <title>blog</title>
    <updated>2019-06-06T06:51:14.506Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://raphael95.github.io/output"/>
    <link rel="self" href="https://raphael95.github.io/output/atom.xml"/>
    <subtitle>Ê∏©ÊïÖËÄåÁü•Êñ∞</subtitle>
    <logo>https://raphael95.github.io/output/images/avatar.png</logo>
    <icon>https://raphael95.github.io/output/favicon.ico</icon>
    <rights>All rights reserved 2019, blog</rights>
    <entry>
        <title type="html"><![CDATA[Dynamic Programming]]></title>
        <id>https://raphael95.github.io/output/post/dynamic-programming</id>
        <link href="https://raphael95.github.io/output/post/dynamic-programming">
        </link>
        <updated>2019-06-06T06:08:47.000Z</updated>
        <summary type="html"><![CDATA[<p>üìùüìì record Dynamic Programming algorithm</p>
]]></summary>
        <content type="html"><![CDATA[<p>üìùüìì record Dynamic Programming algorithm</p>
<!-- more -->
<h2 id="introduction"><strong>Introduction</strong></h2>
<p>&quot;Those who can not remember the past are condemned to repeat it&quot;, is often used to describe the Dynamic Programming, also called DP Algorithm. So, is repeating the things for which you already have the answer, a good thing? A programmer would disagree. That's what Dynamic Programming is about. To always remember answers to the sub-problems you've alreay solved.</p>
<p>We need to break up a problem into a series of overlapping sub-problems, and build up a solutions to larger and sub-probems. If you are given a problem, which can be broken down into smaller sub-problems, and these smaller sub-problems can be broken into smaller ones - and if you manage to find out that these are some overlapping subproblems, then you've encountered a DP problems.</p>
<p>In programming, Dynamic Programming is a powerful technique that allows one to solve different types of problems in time O(N^2) or O(N^3) for which a naive approach would take exponential time.</p>
<p><strong><font color=red>Following are the two main propertites of a problem that suggests that a given problem can be solved using DP</font></strong></p>
<ol>
<li><strong><font color=red>overlapping subproblem</strong></li>
<li><strong>optimal substructure</font></strong></li>
</ol>
<h3 id="1-overlapping-subproblem"><strong>1. overlapping subproblem</strong></h3>
<p>In calculating fibonacci, we can see the function fib(3) is being called 2 times. if we would have stored the value of fib(3), then insted of computing it again, we could have reused the old stored value. There are following two different ways to store the value that these value can be reused:</p>
<ul>
<li>Memoization (Top Down)</li>
<li>Tabulation (Bottom Up)</li>
</ul>
<h3 id="memoization-top-down"><strong>Memoization (Top Down)</strong></h3>
<p>The memoized program for a problem is similar to the recursive version with a small modification that it looks into a lookup table before computing solutions. We initilize a lookup table array with all initial values, whenever we need the solution to a subproblems, we first look into the lookup table, if the precomputed value is there then return that value, otherwise, we calculate the value and put the result in the lookup table so that it can be reused later. Following is the memoized version for Fibonacci Number:</p>
<pre><code>int lookup_table[100];
for(int i = 0; i &lt; 100; i ++)
	lookup_table[i] = -1;
int fibonacci(int n){
	if(lookup_table == -1){
		if(n &lt;=1)
			lookup_table[n] = n;
		else
			lookup_table[n] = fibonacci(n - 1) + fibonacci(n - 2);
	}
	return lookup_table[n];
</code></pre>
<h3 id="tabulation-bottom-up"><strong>Tabulation (Bottom Up)</strong></h3>
<p>THe tabulated program for a given problem builds a table in bottom up fashion and returns the last entry from table. For example, for the same Fibonacci number, we first calculate fib(0) then fib(1) then fib(2) and so on. So iterally, we are building the solutions of subprolems bottom-up. Following is the tabulated version from Fibonacci Number:</p>
<pre><code>int fibonacci(int n){
 	int a[n + 1];
	a[0] = 0;
	a[1] = 1;
	for(int i = 2; i &lt;= n; i ++)
		a[i] = a[i - 1] + a[i - 2];
	return a[n];
</code></pre>
<h3 id="2-optimal-substructure"><strong>2. optimal substructure</strong></h3>
<p>A given problem has optimal substructure propertity if optimal solution of the given problem can be obtained by using optimal solutions of it's subproblems.
For example, the Shortest Path problem has following optimal substructure property:
If a node x lies in the shortest path from a source node u to destination node v then the shortest path from u to v is combination of shortest path from u to x and shortest path from x to v.
On the other hand, the Longest Path problem does'nt not have the. optimal substructure propertity, here, by longest path we mean longest simple path(path without cycle) between two nodes. there are two longest paths fromm q to t: q-&gt;s-&gt;t and q-&gt;r-&gt;t. Unlike shortest path, these longest path do not have the optimal substructure property. For example, the longest path q-&gt;r-&gt;t is not a combination of lonest path from q to r and longest path from r to t, because the longest path from q to r is q-&gt;s-&gt;t-&gt;r and the longest path from r to t is :r-&gt;q-&gt;s-&gt;t.</p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/LongestPath.gif" alt="Âõæ"></p>
<h2 id="dynamic-programming-and-recursion"><strong>Dynamic Programming and Recursion</strong></h2>
<p>Dynamic Programming is basically, recursion plus using common sense. What it means that recursion allows you to repress the value of a function in terms of other values og that function. Where the common on sense tells you that if you implement your function in a way that the recursive calls are done in adavance, and stored for easy access, it will make your program faster. This is what we call Memoization ‚Äî it is memoizating the results of some specific states, which can then be later accessed to solve other sub-problems.</p>
<p>The intuition behind dynamic programming is that we trade space for time. i.r. to say that insted of calculating all the states taking a lot of time but no space, we take up space to store the results of all the sub-problems to save time later.</br></p>
<p>Majority of the Dynamic Programming problems can be categorized into two types:</p>
<ol>
<li>Optimization problems(ÊúÄ‰ºòÂÄºÈóÆÈ¢ò)</li>
<li>Combinatorial problemsÔºàÁªÑÂêà‰ºòÈóÆÈ¢òÔºâ</li>
</ol>
<p>The optimization problems expect you to select a feasible solutions, so that the value of the required function is minimized or maximized. Combinatirial problems expect you to figure out the number of ways to do something, or the probability of some event happening.</p>
<p>The development of a dynamic programming algorith can be broken into a sequence of four steps.</p>
<ol>
<li>Characterize the stracture of an optimal solution.</li>
<li>Recursively define the value of an optimal solution.</li>
<li>Compute an optimal solution from computed information.</li>
<li>Construct an optimal solution from computed information.</li>
</ol>
<p>Step 1~3 form the basis of a dynamic programming solution to a problrms, step 4 can be omitted id only the value of an optimal solution is required. When we do perform step 4, we sometimes maintain additional information during the computation in step 3 to ease the construction of an optimal solution.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[master  theorem]]></title>
        <id>https://raphael95.github.io/output/post/master-theorem</id>
        <link href="https://raphael95.github.io/output/post/master-theorem">
        </link>
        <updated>2019-06-04T06:19:08.000Z</updated>
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<h2 id="introduction"><strong>Introduction</strong></h2>
<p>The master mwthod provides a 'cookbook' method for solving recurrences of the form</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy="false">)</mo><mo>+</mo><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = a\Gamma(\frac{n}{b}) + \hat{a}(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord mathdefault">a</span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>‚â•</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚â•</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>‚â•</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚â•</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> are constants and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> is an asymptotically positive function. The master method requires memorization of three cases, but then the solution of many recurrences can be determined quite easily, often without pencil and paper</p>
<h3 id="the-master-theorem"><strong>the master theorem</strong></h3>
<p>The master theorem method depends on the following theorem.</br>
Theorem 1.1</br>
Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>‚â•</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚â•</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>‚â•</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚â•</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> be constants, let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> be a function, and let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> be defined on the nonnegative integers ny the recurrence</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy="false">)</mo><mo>+</mo><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = a\Gamma(\frac{n}{b}) + \hat{a}(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord mathdefault">a</span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>where we interpret <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>n</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">frac{n}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span></span> to be mean either <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">‚åä</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo fence="true">‚åã</mo></mrow><annotation encoding="application/x-tex">\left \lfloor \frac{n}{b} \right \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">‚åä</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">‚åã</span></span></span></span></span></span>  or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">‚åà</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo fence="true">‚åâ</mo></mrow><annotation encoding="application/x-tex">\left \lceil \frac{n}{b} \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">‚åà</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">‚åâ</span></span></span></span></span></span>. THen <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> can be bounded as asymptotically as follow:</p>
<ol>
<li>if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mi>b</mi><mi>a</mi></msubsup><mo>‚àí</mo><mi>œµ</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n) = O(n^{log_{b}^{a}-\epsilon})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.12998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.87998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.214em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mbin mtight">‚àí</span><span class="mord mathdefault mtight">œµ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> for some constants <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>œµ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">œµ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mi>b</mi><mi>a</mi></msubsup></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = \Theta(n^{log_{b}^{a}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.12998em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.87998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.214em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mi>b</mi><mrow><mi>a</mi><mo stretchy="false">]</mo></mrow></msubsup></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n) = \Theta(n^{log_{b}^{a]}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.35436em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.10436em;"><span style="top:-3.1043600000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7413600000000002em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0590857142857144em;"><span style="top:-2.188485714285714em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.059085714285714em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.3472285714285714em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>‚àó</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = \Theta(n^{log_{b}{a}} * lgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">‚àó</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œ©</mi><mo stretchy="false">(</mo><mi>n</mi><mo>‚àó</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi><mo>+</mo><mi>œµ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n) = \Omega(n*log_{b}{a}+\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œ©</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">‚àó</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">œµ</span><span class="mclose">)</span></span></span></span> for some constant <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>œµ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">œµ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, and if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy="false">)</mo><mo>‚â§</mo><mi>c</mi><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\hat{a}(\frac{n}{b}) \leq c\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault">a</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚â§</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> for some constant <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>‚â§</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚â§</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> and all sufficiently large n, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = \Theta(\hat{a}(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>Before applying the master theorem to some examples, let's spend a moment trying to understand what is says. In each od the cases, we are comparing the function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> with the function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{log_{b}{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span>, Intutively, the solution to the recurrence is determined by the larger of two functions. If, as in case 1, the function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{log_{b}{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span> is the larger, then the solution is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = \Theta(\hat{a}(n^{log_{b}{a}}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. If, as in case 3, the function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> is larger, then the solution is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = \Theta(\hat{a}(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. If, as in case 2, t
he function are the same size, we multiply by alogarithmic factor, and the solution is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Œì</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Œò</mi><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>‚àó</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma(n) = \Theta(n^{log_{b}{a}}) = \Theta(\hat{a}(n) * lgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œì</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Œò</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">‚àó</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>Beyond this function, there are some technicalities that must be understood. In the first caee, not only must <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> be smaller than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{log_{b}{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span>, it must be polynomially smaller. That is, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> must be asymptotically smaller 	than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{log_{b}{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span> by a factor of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>œµ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">œµ</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>œµ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\epsilon &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">œµ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. In the third case, not only must <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> be larger than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{log_{b}{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span>, it must be polynomially larger and in addition satisfy the &quot;regularity&quot; condition that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy="false">)</mo><mo>‚â§</mo><mi>c</mi><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\hat{a}(\frac{n}{b}) \leq c\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault">a</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">‚â§</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>. This condition is satisfied by most of the polynomially bounded functions that we shall encounter.</p>
<p>It is important to realize that the three cases do not cover all the possibilities for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>. There is a gap between cases 1 and 2 when <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> is smaller than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{log_{b}{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span> but not polynomially smaller. Similary, there is a gap between case 2 and 3 when <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> is larger than <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{log_{b}{a}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></span> but not polynonially larger. If the function <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{a}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> falls into one of these gaps, or if the regularity condition in case 3 fails to hold, the master theorem cannot used to solve the recurrence.</p>
<p>zero-centered is an important operation for data before using PCA,
as it will extract the matric feature vector</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary  Tree  and  Traversal]]></title>
        <id>https://raphael95.github.io/output/post/binary-tree-and-traversal</id>
        <link href="https://raphael95.github.io/output/post/binary-tree-and-traversal">
        </link>
        <updated>2019-05-31T03:14:33.000Z</updated>
        <summary type="html"><![CDATA[<p>üìùüìì record binary tree and trevsersal</p>
]]></summary>
        <content type="html"><![CDATA[<p>üìùüìì record binary tree and trevsersal</p>
<!-- more -->
<h2 id="introduction"><strong>Introduction</strong></h2>
<p>Tree represents the nodes connected by edges. We will discuss binary tree or binary search tree specifically.</p>
<p>Binary Tree is a special data structure used for data storage purpose. A binary tree has s a special condition that each node can have a maximum of two children. A binary tree has the benefits of both an ordered arrat and a linked list as search is is as quick as in a sorted array and insertion or deletion operation are as fast as in linked list.</p>
<p>We first define a tree struct as follows:</p>
<pre><code>struct Node{
	int data;
	struct Node * left_child;
	struct Node * right_child;
};

struct Tree{
	struct Node * root;
};
</code></pre>
<p><img src="https://www.tutorialspoint.com/data_structures_algorithms/images/binary_tree.jpg" alt="binary_tree"></p>
<h3 id="1-build-a-binary-treerecursion">1. build a binary tree(recursion)</h3>
<p>Creating a binary tree can be implemented by insertion operation, also, two conditions can be followed as: building a normal binary tree or building a binary search tree, and we only talk about normal binary tree. When constructing a normal binary tree, we need a principle that can locate the position node to be inserted, here, we usually use Pre-Order traversal to complete the insertion operation.</p>
<p>pseudocode in C:</p>
<pre><code>struct Node * construct_tree(struct Node * node){
	int data;
	printf(&quot;please input the data: &quot;);
	scanf(&quot;%d&quot;, &amp;data);
	if(data == -1)
		return NULL;
	else{
		node = (struct Node *)malloc(sizeof(struct Node));
		node-&gt;data = data;
		node-&gt;left_child = construct_tree(node-&gt;left_child);
		node-&gt;right_child = construct_tree(node-&gt;right_child);
	}
	return node;

void construct(struct Tree * t){
	t-&gt;root = construct_tree(t-&gt;root);
}
</code></pre>
<h3 id="2-pre-order-traversalrecursion">2. Pre-Order traversal(recursion)</h3>
<p>traverse the root node of a binary tree first, then left child node and right child node at last.</p>
<p>pseudocode in C:</p>
<pre><code>void pre(struct Node * node){
	if(node != NULL){
		printf(&quot;%d &quot;, node-&gt;data);
		pre(node-&gt;left_child);
		pre(node-&gt;right_child);
	}
}

void pre_order(struct Tree *){
	pre(t-&gt;root);
}
</code></pre>
<h3 id="3-in-order-traversalrecursion">3. In-Order traversal(recursion)</h3>
<p>traverse the left child node of a binary tree first, then root node and right child node at last.</p>
<p>pseudocode in CÔºö</p>
<pre><code>void in(struct Node * node){
	if(node != NULL){
		in(node-&gt;left_child);
		printf(&quot;%d &quot;, node-&gt;data);
		in(node-&gt;right_child);
	}
}

void in_order(struct Tree * t){
	in(t-&gt;root);
}
</code></pre>
<h3 id="4-post_order-traversalrecursion">4. Post_Order traversal(recursion)</h3>
<p>traverse the left child node of a binary tree first, then right child node and root node at last.</p>
<p>pseudocode in C:</p>
<pre><code>void post(struct Node * node){
	i(node != NULL){
		post(node-&gt;left_child);
		post(node-&gt;right_child);
		printf(&quot;%d &quot;, node-&gt;data);
	}
}

void post_order(struct Tree * t){
	post(t-&gt;root);
}
</code></pre>
<h3 id="5-level-traversalusing-queue">5. level traversal(using Queue)</h3>
<p>traverse a binary tree level by level, we can store the nodes those have benn visited with the help of Queue structure. In able to implement the queue efficiently, we use Circle Queue</p>
<p>first, define a Queue, code in C:</p>
<pre><code>#define MAX_QUEUE 20
struct Queue{
	struct Node **base;
	int front;
	int rear;
};

bool isEmpty(struct Queue * q){
	if(q-&gt;front == q-&gt;rear)
		return true;
	else
		return false;
}

bool isFull(struct Queue * q){
	if((q-&gt;rear + 1) / MAX_QUEUE == q-&gt;front)		return true;
	else
		return false;
}	

void enqueue(struct Queue * q, struct Node * node){
	if(isFull(q))
		return;
	else{
		if(isEmpty(q))
			q-&gt;base[q-&gt;rear] = node;
		else{
			q-&gt;rear = (q-&gt;rear + 1) / MAX_QUEUE;
			q-&gt;base[q-&gt;rear] = node;
		}
	}
}

struct Node * dequeue(struct Queue * q){
	if(!isEmpty(q)){
		struct Node * tmp = q-&gt;base[q-&gt;front];
		q-&gt;front = (q-&gt;front + 1) / MAX_QUEUE;
		return tmp;
	}
	else
		exit(-1);
}
		
</code></pre>
<p>next, we can implement the level traversal</p>
<pre><code>void level_traverse(struct Tree * t){
	struct Queue * q = (struct Queue *)malloc(siezof(struct Queue));
	q-&gt;base = (struct Node **)malloc(sizeof(struct Node *));
	q-&gt;front = 0;
	q-&gt;rear = 0;
	enqueue(q, t-&gt;root);
	struct Node * tmp;
	while(!isEmpty(q)){
		tmp = dequeue(q);
		printf(&quot;%d &quot;, tmp-&gt;data);
		if(tmp-&gt;left_child)
		
			enqueue(q, tmp-&gt;left_child);
		if(tmp-&gt;right_child)
			enqueue(q, tmp-&gt;right_child);
	}
}
</code></pre>
<h2 id="non-recursion-traversalusing-stack"><strong>Non-recursion traversal(using Stack)</strong></h2>
<h3 id="1-pre-order-traversal">1. Pre-Order traversal</h3>
<p>the procedure of algorithms:</p>
<ol>
<li>push the root node to stack;</li>
<li>if the stack is not empty, pop the top element of stack;</br>
(1) push it's right child node to stack if exists;</br>
(2) push it's left child node to stack if exists;</br></li>
<li>repeat step 2 until stack is empty</li>
</ol>
<p>pseudocode in C:</p>
<pre><code>void pre_order(struct Tree * tree){
	struct Stack * stack = (struct Stack *)malloc(sizeof(struct Stack));
	init_stack(stack);
	push(stack, tree-&gt;root);
	struct Node * tmp;
	while(!isEmpty(stack)){
		tmp = pop(stack);
		printf(&quot;%d &quot;, tmp-&gt;data);
		if(tmp-&gt;right_child)
			push(stack, tmp-&gt;right_child);
		if(tmp-&gt;left_child)
			push(stack, tmp-&gt;left_child);
	}
	printf(&quot;\n&quot;);
}
</code></pre>
<h3 id="2-post_order-traversal">2. Post_Order traversal</h3>
<ol>
<li>
<p>push the root node to stack;</p>
</li>
<li>
<p>if the stack is not empty, get the top element of stack(<font color=red><strong>not pop</strong></font>);</br>
(1) if it's left child node has been visited or null and right child node has been visited or null, pop the top element of stack and print.</br>
(2) if it's right child node is not null and unvisited, push it into the stack and set it as visited;</br>
(3) if it's left child node is not null and unvisited, push it into the stack and set it as visited;</br></p>
</li>
<li>
<p>repeat step 2 until stack is empty</p>
</li>
</ol>
<p>pseudocode in C:</p>
<pre><code>void post_order(struct Tree * tree){
	struct Stack * stack = (struct Stack *)malloc(sizeof(struct Stack));
	init_stack(stack);
	struct Node * tmp;
	push(stack ,tree-&gt;root);
	while(!isEmpty(stack)){
		tmp = get_top(stack);
		if(tmp-&gt;left_child == NULL || tmp-&gt;left_child-&gt;visited == 1) &amp;&amp; (tmp-&gt;right_child == NULL || tmp-&gt;right-&gt;visited == 1){
			tmp = pop(stack);
			printf(&quot;%d &quot;, tmp-&gt;data);
		}
		if(tmp-&gt;right_child &amp;&amp; tmp-&gt;right_child-&gt;visited == 0){
			push(stack, tmp-&gt;right_child);
			tmp-&gt;right_child-&gt;visited = 1;
		}
		if(tmp-&gt;left_child &amp;&amp; tmp-&gt;left_child-&gt;visited == 0){
			push(stack, tmp-&gt;left_child);
			tmp-&gt;left_child-&gt;visited = 1;
		}
	}
	printf(&quot;\n&quot;);
}
</code></pre>
<h3 id="3-in-order-traversal">3. In-Order traversal</h3>
<ol>
<li>
<p>set it'visited equals to 1 push the root node to stack;</p>
</li>
<li>
<p>if the stack is not empty, get the top element of stack(<font color=red><strong>not pop</strong></font>)</br>
(1) if it's visited equals to 2, pop the top element of stack and print. continue</br>
(2) if it's left child and right child are all null, pop the top element of tack and print; continue</br></p>
<p>(3) pop itself from top of stack;</br>
(4) if it's right child node is not null, set visited as 1 and push it into stack;</br>
(5) set visited as 2 push itself into stack;</br>
(6) if it's left child node is not null, set visited as 1 push it into stack;</br></p>
</li>
<li>
<p>repeat step 2 until stack is empty</p>
</li>
</ol>
<p>pseudocode in C:</p>
<pre><code>void in_order(struct Tree * tree){
	struct Stack * stack = (struct Stack *)malloc(sizeof(struct Stack));
	init_stack(stack);
	tree-&gt;root-&gt;visited = 1;
	push(stack, tree-&gt;root);
	struct Node * tmp
	while(!isEmpty(stack)){
		tmp = get(stack);
		if(tmp-&gt;visited == 2){
			tmp = pop(stack);
			printf(&quot;%d &quot;, tmp-&gt;data);
			continue;
		}
		if(tmp-&gt;left_child == NULL &amp;&amp; tmp-&gt;right_child == NULL){
			tmp = pop(stack);
			printf(&quot;%d &quot;, tmp-&gt;data);
			continue;
		}
		tmp = pop(stack);
		if(tmp-&gt;right_child){
			tmp-&gt;right_child-&gt;visited = 1;
			push(stack, tmp-&gt;right_child);
		}
		tmp-&gt;visited = 2;
		push(stack, tmp);
		if(tmp-&gt;left_child){
			tmp-&gt;left_child-&gt;visited = 1;
			push(stack, tmp-&gt;left_child);
		}
	}
	printf(&quot;\n&quot;);
}
		
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pattern  Search]]></title>
        <id>https://raphael95.github.io/output/post/pattern-search</id>
        <link href="https://raphael95.github.io/output/post/pattern-search">
        </link>
        <updated>2019-05-30T10:11:05.000Z</updated>
        <summary type="html"><![CDATA[<p>üìùüìì record pattern search algorithms and introduce two solutions</p>
]]></summary>
        <content type="html"><![CDATA[<p>üìùüìì record pattern search algorithms and introduce two solutions</p>
<!-- more -->
<h2 id="introduction">Introduction</h2>
<p>Actually, pattern searching is an important problem in computer sciemce. When we do search for a string in nptepad/word file or browser or database, pattern searching algorithms are used to show the search results. The essence is the problem of finding occurrences of pattern string within another string or body of text, there are many different algorithms for efficient searching.</p>
<h3 id="1-brute-force">1. brute force</h3>
<blockquote>
<p>time complexity: O(N * M)
N is the len of text string, M is the len of pattern string
such as : target = &quot;ABABDABACDABABCABAB&quot;, pattern = &quot;ABABCABAB&quot;</p>
</blockquote>
<p>pseudocode in C:</p>
<pre><code>void pattern_search(char *t, char *p){
	int len_t = strlen(t);
	int len_p = strlen(p);
	bool found;
	for(int i = 0; i &lt; len_t - len_p; i ++){
		found = true;
		for(int j = i; j &lt; i + len_p; j ++){
			if(t[j] != p[j - i]){
				found = false;
				break;
			}
		}
		if(found)
			return i;
	}
	return -1;
}
</code></pre>
<h3 id="2-knuth-morris-pratt-algorithm">2. Knuth-Morris-Pratt Algorithm</h3>
<blockquote>
<p>time complexity: is O(N + M)</p>
</blockquote>
<p>the naive pattern searching/brute force algorithms doesn't work well in cases where we see many matching characters followed any mismatching character.</p>
<p>The KMP matching algorithm uses degenerating property(pattern having same sub-patterns more than once in the pattern)of the pattern and improves the worst case complexity to O(N).The basic idea behind KMP's algorithms is : whenever we detect a mismatch(after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the repeated characters we have known. Here, we need an auxiliary array named next to store the amount of longest common prefix and suffix.</p>
<p>pseudocode in CÔºö</p>
<pre><code>void prefix(char *p, int *next){
	int len_p = strlen(p);
	for(int i = 1; i &lt; len_p; i ++){
		if(p[i] == p[next[i - 1]])
			next[i] = next[i - 1] + 1;
		else{
			if(p[i] == p[0])
				next[i] = 1;
			else
				next[i] = 0;
		}
	}
}

int pattern_search(char *t, char *p){
	int len_t = strlen(t);
	int len_p = strlen(p);
	int *next = (int *)malloc(sizeof(int));
	prefix(p, next);
	
	int i = 0;
	int j = 0;
	while(i &lt; len_t){
		if(t[i] == p[j]){
			i ++;
			j ++;
		}
		if(j == len_p)
			return i - j;
		if(i &lt; len_t &amp;&amp; t[i] != p[j]){
			if(j != 0)
				j = next[j - 1];
			else
				i += 1;
		}
	}
	return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Search  Algorithms]]></title>
        <id>https://raphael95.github.io/output/post/search-algorithms</id>
        <link href="https://raphael95.github.io/output/post/search-algorithms">
        </link>
        <updated>2019-05-30T07:33:49.000Z</updated>
        <summary type="html"><![CDATA[<p>üìùüìì record search algorithms</p>
<p>they are: linear search„ÄÅbinary search„ÄÅlinear selection„ÄÅTop K problem</p>
]]></summary>
        <content type="html"><![CDATA[<p>üìùüìì record search algorithms</p>
<p>they are: linear search„ÄÅbinary search„ÄÅlinear selection„ÄÅTop K problem</p>
<!-- more -->
<h2 id="introduction"><strong>Introduction</strong></h2>
<p>Searching Algorithms are designed to check for an element or retrieve an element from any dta structure where it is stored. Based on the type of search operation, thesealgorithms are generally classified into two categories:</p>
<ol>
<li>Sequential Search: In this, the list or array is traversed sequentially and every element is checked. For example: Linear Search</li>
<li>Interval Search: These algorithms are specifically designed for searching in sorted data-structures. These type of searching algorithms are much more efficient than Linear Search as they repeatedly target the center of the search structure and divide the search space in half. For example: Binary Search.</li>
</ol>
<h2 id="linear-search"><strong>Linear Search</strong></h2>
<blockquote>
<p>time complexity: O(N)</p>
</blockquote>
<p>Linear search is uesed on a collections of items, it relies on the technique of traversing a list from start to end by exploring properties of all the elements that are found on the way.</p>
<p>For example, consider an array of integers of size N, you should find and print the position of all the elements with value X. Here, the linear search is based on the idea of matching each element from the begaining of the list to the end of the list with the integer X, and then printing the position of element if the condition is 'True'.</p>
<p>pseudocode in C:</p>
<pre><code>void find(int *a, int len){
	for(int i = 0; i &lt; len; i ++){
		if(a[i] == '5')
			print(&quot;%d \n&quot;, i);
	}
}
</code></pre>
<h2 id="binary-search"><strong>Binary Search</strong></h2>
<blockquote>
<p>time complexity: O(lgN)</p>
</blockquote>
<p>Binary search works only on a sorted set of elements. To use binary search on a collection, the collection must first be sorted.</p>
<p>When binary search is used to perform operations on a sorted set, the number of iterations can always be reduced on the basis of the value that is being searched.</p>
<p>pseudocode in C:</p>
<pre><code>int bin_search(int *a, int low, int high, const int x){
	int index = -1;
	int mid;
	if(low &lt;= high){
		mid = (low + high) / 2;
		if(a[mid] == x)
			return mid;
		if(a[mid] &lt; x)
			index = bin_search(a, mid + 1, high, x);
		else
			index = bin_search(a, low, mid - 1, x);
	}
	return index;
}
</code></pre>
<h2 id="linear-selection"><strong>Linear Selection</strong></h2>
<blockquote>
<p>time complexity: O(N)</p>
</blockquote>
<p>Now, we need to <strong><font color=red>find the k-th minimum/maximum item in an unsorted array,</font></strong> as we know, the selection problem can be solved in O(N * lgN) time, since we can sort the array using heap sort or merge sort and then simply index the k-th element in the output array. There are faster algorithms that the work can be done in expected linear time.</p>
<p>As in QuickSort algorithms, the idea is to partition the input array recursively. But unlike quicksort, which recursively process both sides of the partition, in linear selection, it only works on one side of the partition. This different shows up in the analysis: whereas quicksort has an expected running time of O(N * lg N), the expected time of linear selection is O(N).</p>
<p>pseudocode in C:</p>
<pre><code>int linear_selection(int *a, int low, int high, const in k){
	int count = 0;
	if(low == high)
		return a[low];
	int pivot = partition(a, low, high);
	count = oivot - low + 1;
	if(count &gt;= k)
		return linear_selection(a, low, count, k);
	else
		return linear_selection(a, count + 1, high, k - count);
</code></pre>
<h2 id="top-k-selection-problem"><strong>Top K Selection problem</strong></h2>
<p>Similar with linear selction problem, now, we need to <strong><font color=red>find the top k elements in an unsorted array,</font></strong> of course, you can write down such code as below:</p>
<pre><code>results = sorted(array, reverse=True)[: 10]
</code></pre>
<p>Anything involving a sort will usually take O(N * lgN) time, which will keep you waiting around for several seconds or even minutes when dealing with lots of items. An O(N * lgN) algorithm, for large N, simply cannot be run in realtime when users are waiting.</p>
<p>There are two ways to resolve the problem:</p>
<h3 id="1-solution-1-using-heap">1. solution 1: using heap</h3>
<blockquote>
<p>time complexity: O(N * lgK), space complecity: O(K)</p>
</blockquote>
<p>Luckily, finding the top k items can be done in O(N * lgK) time, which is much, much faster than O(N * lgN), using a heap, which is actually a priority queue. Assuming that we need to select top k maximum items in a list, as in heap sort, First, accordingly, we should build a minimum heap of size K to store the target items, and the top is always minimum item in the heap. Second, adding the rest of items in array recursively to heap if it is larger than top  element in the heap, Third, adjusting the heap and always place the minimum item to the top in the heap.</p>
<p>pseudocode in C:</p>
<pre><code>void adjust_heap(int *a, int root, int len){
	int left_child = 2 * root + 1;
	int right_child = 2 * root + 2;
	int max_child;
	if(left_child &gt;=len)
		return;
	else{
		if(right_child &gt;= len)
			max_child = left_child;
		else
			max_child = a[left_child] &gt; a[right_child]? left_child: right_child;
		if(a[root] &gt; a[max_child]){
			int tmp = a[root];
			a[root] = a[max_child];
			a[max_child] = tmp;
			adjust_heap(a, max_child, len);
		}
	}
}

void build_heap(int *a, int len){
	for(int i = len / 2 - 1; i &gt;=0; i --)
		adjust_heap(a, i, len);
}

void top_k(int *a, int len, const in k){
	int heap[k], i;
	for(i = 0; i &lt; k; i ++)
		heap[i] = a[i];
	build_heap(heap, k);
	for(i = k; i &lt; len; i ++){
		if(a[i] &gt; heap[0]){
			heap[0] = a[i];
			adjust(heap, 0, k); 
		}
	}
	
	// print the top k items;
	for(i = 0; i &lt; k; i ++)
		printf(&quot;%d &quot;, heap[i]);
}

</code></pre>
<h3 id="2-solution-2-using-linear-selection">2. solution 2: using linear selection</h3>
<blockquote>
<p>time complexity: O(N), space complexity: O(N)</p>
</blockquote>
<p>as we can see, the linear selection are faster than heap, however, it needs more space and may not wok well when space is limited.</p>
<p>we have learned about the linear selection algorithm in previous section, it uses partition function in QuickSort to get the pivot item and divide the array into two sublists, if the amount of left sublist equals to K, the left sublist will be the final Top K items, if amount is less than K, it will continue to find the rest (K - amount) items in right sublists, otherwise, it will continue to find the pivot that equals to K in left sublists.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sorting  Algorithms]]></title>
        <id>https://raphael95.github.io/output/post/sort-algorithms</id>
        <link href="https://raphael95.github.io/output/post/sort-algorithms">
        </link>
        <updated>2019-05-27T15:03:27.000Z</updated>
        <summary type="html"><![CDATA[<p>üìíüìùüìì record seven sort algorithms.</p>
<p>they are: bubble sort „ÄÅselection sort„ÄÅinsertion sort„ÄÅquick sort „ÄÅheap sort„ÄÅmerge sort„ÄÅcounting sort</p>
]]></summary>
        <content type="html"><![CDATA[<p>üìíüìùüìì record seven sort algorithms.</p>
<p>they are: bubble sort „ÄÅselection sort„ÄÅinsertion sort„ÄÅquick sort „ÄÅheap sort„ÄÅmerge sort„ÄÅcounting sort</p>
<!-- more -->
<h2 id="introduction">Introduction</h2>
<p>Some algorithms(<strong><a href="#selection">selection</a>, <a href="#bubble">bubble</a>, <a href="#heap">heap</a></strong>) work by moving elements to their final position, one at a time. You sort an array of size N, put 1 item in place and continue sorting and array of size N -1,</p>
<p>Some algorithms(<strong><a href="#insertion">insertion</a>, <a href="#quicksort">quicksort</a>, <a href="#counting">counting</a></strong>)put items to temporary place, closer to their final position, moving them closer to final position ,in each iteration.</p>
<p>Some algorithms(<strong><a href="#merge">merge</a></strong>) start with a 'sorted list ' of one element, and merge unsorted items into it, one at a time</p>
<h3 id="note">note</h3>
<ul>
<li>assume we are sorting a list or array of N elements</li>
<li>once sorted, smaller items are on the left, and larger items are on the right</li>
</ul>
<h3 id="span-idbubblebubble-sortspan"><strong><span id="bubble">Bubble Sort</span></strong></h3>
<blockquote>
<p>best: O(N), worst: O(N^2)</p>
</blockquote>
<p>¬†¬†starting on the left, compare adjacent items and keep 'bubbling' the the larger one to the right(it's in its final place), bubble sort the remaining N -1 items.</p>
<p>¬†¬†in each iteration, it will find the largest one in the rest of an array, and place it in the right.</p>
<p>pseudocode in C language:</p>
<pre><code>void bubble_sort(int *a, int len){
	int tmp;
	for(int i = 0; i &lt; len; i ++){
		for(int j = 0; j &lt; len - i - 1; i ++){
			if(a[j] &gt; a[j + 1]){
				tmp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = tmp;
			}
		}
	}
}
</code></pre>
<h3 id="span-idselectionselection-sortspan"><strong><span id="selection">Selection Sort</span></strong></h3>
<blockquote>
<p>best/worst: O(N^2)</p>
</blockquote>
<p>¬†¬†scan all items and find the smallest. Swap it into the position as the first item. Repeat the selection sort on the remaining N - 1 items</p>
<p>¬†¬†it just like the bubble sort, the outer iteration from 0 to N - 1Ôºå the inner iteration is to find the minimun item, and always swap it with i.</p>
<pre><code>void selection_sort(int *a, int len){
	int min, index, tmp;
	for(int i = 0; i &lt; len; i ++){
		min= a[i];
		for(int j = i; j &lt; len; j ++){
			if(a[j] &lt; min){
				min = a[j];
				index = j;
			}
			tmp = a[i];
			a[i] = a[index];
			a[index] = tmp;
		}
	}
}
</code></pre>
<h3 id="span-idinsertioninsertion-sortspan"><strong><span id="insertion">Insertion Sort</span></strong></h3>
<blockquote>
<p>best: O(N)Ôºå worst: O(N^2)</p>
</blockquote>
<p>¬†¬†start with a sorted list of 1 element on the left, and N - 1 unsorted items on the right. Taking the first unsorted item (element #2) and insert it into the sorted list, moving elements as neccesary. We now have a sorted list of size 2, and N -2 unsorted items, repeat for all items.</p>
<pre><code>void insertion_sort(int *a, int len){
	int min;
	for(int i = 0; i &lt; len; i ++){
		int j = i;
		min = a[i];
		while(j &gt; 0 &amp;&amp; a[j - 1] &gt; min){
			a[j] = a[j - 1];
			j = j - 1;
		}
		a[j] = min;
	}
}
</code></pre>
<h3 id="span-idquicksortquick-sortspan"><strong><span id="quicksort">Quick Sort</span></strong></h3>
<blockquote>
<p>best: O(N * lgN), avg: O(N * lgN), worst: O(N^2)</p>
</blockquote>
<p>there are many versions of QuickSort, which is one of the most popular sorting methods due to its speed O(N * lgN) average, but O(N^2) worst cae, here's a few:</p>
<ul>
<li>pick a 'pivot' item</li>
<li>partition the other items by adding them to a 'less than pivot' sublist, and 'larger than pivot' sublist</li>
<li>the pivot goes between the two sublists</li>
<li>repeat the quicksort on the two sublists until you get to a sublist of size 1(which is sorted)</li>
</ul>
<p><strong>the most important in  QuickSort is partition function</strong></p>
<pre><code>int partition(int *a, int low, int high){
	int pivot = a[i];
	int i = low;
	int j = high;
	while(i &lt; j){
		while(j &gt; i &amp;&amp; a[j] &gt;= pivot)
			j --;
		if(j &gt; i)
			a[i] = a[j];
		while(i &lt; j &amp;&amp; a[i] &lt;=pivot)
			i ++;
		if(i &lt; j)
			a[j] = a[i];
	}
	a[i] = pivot;
	return i;
}

int quick_sort(int *a, int i, int j){
	if(i &lt; j){
		int pivot = partition(a, i, j);
		quick_sort(a, i, pivot - 1);
		quick_sort(a, pivot + 1, j);
</code></pre>
<p>however, the algorithms in the partition above has a defects, the time complexity can be O(N^2), we will elaborate how it happens now. <strong>If a bad pivot is chosen, you can imagine that the 'less than pivot' sublist is always empty, that means  we are only creating a sublist of one item smaller each time, which gives us O(N^2)behavior in the worst case. If you choose the first item, it may be the smallest item in the sorted list and give worst-case behavior. <font color=red>You can choose a random item, or median-of three(front,middle,rear)</font>.</strong></p>
<p>an improved partition function in QuickSort :</p>
<pre><code>void compare(int *a, int *b){
	if(*a &gt; *b){
		int tmp;
		tmp = *a;
		*a = *b;
		*b = tmp;
	}
}

void swap(int *a, int *b){
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

void partition(int *a, int low, int high){
	int i = low;
	int j = high;
	int middle = (i + j) / 2;
	compare(&amp;a[i], &amp;a[middle]);
	compare(&amp;a[i], &amp;a[j]);
	compare(&amp;a[middle], &amp;a[j]);
	swap(&amp;a[i], &amp;a[middle]);
	int picot = a[i];
	while(i &lt; j){
		while(j &gt; i &amp;&amp; a[j] &gt;= picot)
			j --;
		if(j &gt; i)
			a[i] = a[j];
		while(i &lt; j &amp;&amp; a[i] &lt;=pivot)
			i ++;
		if(i &lt; j)
			a[j] = a[i];
		}
	a[i] = pivot;
	return i;
}
</code></pre>
<h3 id="span-idmergemerge-sortspan"><strong><span id="merge">Merge Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N * lgN)</p>
</blockquote>
<p>Merge sort is a divid-and-conquer algorithm based on the idea of breaking down a list into several sublists until each sublists consists of a single element and merging those sublists to a sorted list.</p>
<ul>
<li>divide the unsorted lists into N sublists, each containing 1 element.</li>
<li>take adjacent pair of two singleton lists and merge them to from a list of 2 elements, N will now convert into N / 2 lists of size 2.</li>
<li>repeat the process till a single sorted lists of obtained.</li>
</ul>
<pre><code>void merge(int *a, int low, int middle, int high){
	int left_low = low;
	int left_high = middle;
	int right_low = middle + 1;
	int right_high = high;
	int k = 0;
	int *tmp = (int *)malloc(sizeof(int) * (high - low + 1));
	for(k &lt; high; left_low &lt; left_high &amp;&amp; right_low &lt; right_high; k ++){
		if(a[left_low] &lt; a[right_low])
			tmp[k] = a[left_low ++];
		else
			tmp[k] = a[right_low ++];
	}
	if(left_low &lt; left_high){
		for(int i = left_low; i &lt; left_high; i ++)
			tmp[k ++] = a[i];
	if(right_low &lt; right_high){
		for(int i = right_low; i &lt; right_low; i ++)
			tmp[k ++] = a[i];
	
	for(int i = 0; i &lt; high - low + 1; i ++)
		a[low + i] = tmp[i];
	
	free(tmp);
}

void merge_sort(int *a, int low, int high){
	if(low &lt; high){
		int middle = (low + high) / 2;
		merge_sort(a, low, middle);
		merge_sort(a, middle + 1, high);
		merge(a, low, middle, high);
	}
}
	
</code></pre>
<h3 id="span-idheapheap-sortspan"><strong><span id="heap">Heap Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N * lgN)</p>
</blockquote>
<p>Heaps can be used in sorting an array, in max-heaps, maximum element will always be at the root, Heap sort uses this property of heap to sort the array. Adding all items into a heap, Pop the largest item from the heap and insert it at the end(final position), and repeat for all items.</p>
<p><strong>time complexity analysis</strong>:</p>
<p><font color=red>Creating the heap needs O(N * lgN).Poping items from heap is O(1), and adjust the heap after pop needs O(lgN), there are N pops, so there is another O(N * lgN) factor, which is O(N * lgN) overall.</font></p>
<p><font color=blue>Heap sort has O(N * lgN) behavior, even in the worst case, making it good for real-time applications.</font></p>
<pre><code>void adjust_heap(int *a, int root, int len){
	int left_child = 2 * root + 1;
	int right_child = 2 * root + 2;
	int max_child;
	if(left_child &gt;= size)
		return;
	else{
		if(righ_child &gt;= size)
			max_child = left_child;
		else
			max_child = a[left_child] &gt; a[right_child]? left_child, right_child;
		if(a[root] &lt; a[max_child]){
			int tmp = a[root];
			a[root] = a[max_child];
			a[max_child] = tmp;
			adjust_heap(a, max_child, len);
		}
	}
}

void build_heap(int *a, int len){
	for(int i = len / 2 - 1; i &gt;=0; i --)
		adjust_heap(a, i, len);
}

void heap_sort(int *a, int len){
	build_heap(a, len);
	for(int i = len - 1; i &gt;=0; i ++){
		int tmp = a[0];
		a[0] = a[i];
		a[i] = tmp;
		adjust_heap(a, 0, i);
	}
}
</code></pre>
<h3 id="span-idcountingcounting-sortspan"><strong><span id="counting">Counting Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N)</p>
</blockquote>
<p>Assuming the data are integers, in a range of 0-K. Creating an array of size K to keep track of how many items appears(3 items with value 0, 4 items with value 1, etc.). Given this count, you can tell the position of an item ‚Äî‚Äî all the 1's must come after the 0's, of which these are 3. Therefore, the 1's start at item #4. Thus, we can scan the items and insert them into their proper position. <font color=red>In Counting Sort, the frequencies of distincts of the array to be sorted is counted and stored in an auxiliary array, by mapping its as value of the auxiliary array.</font></p>
<ul>
<li>Creating the auxiliary array is O(N)</li>
<li>Inserting items into their proper position needs O(N)</li>
</ul>
<pre><code>void counting_sort(int *a, int len){
	// find the maximum value
	int i;
	int max = 0;
	for(i = 0; i &lt; len; i ++){
		if(a[i] &gt; max)
			max = a[i];
	
	// initialize auxiliary array 
	int auxiliary[max];
	for(i=0; i &lt; max; i ++)
		auxiliary[i] = 0;
	
	for(i = 0; i &lt; len; i ++)
		auxiliary[a[i]] ++;
	
	int sorted_a[len];
	int j = 0;
	for(i = 0; i &lt;= max; i ++){
		counts = auxiliary[i];
		while(count --){
			sorted_a[j] = i;
			j ++;
		}
	}
	
	for(i = 0; i &lt; len; i ++){
		a[i] = auxiliary[i];
}
	
</code></pre>
]]></content>
    </entry>
</feed>