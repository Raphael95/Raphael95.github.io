<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://raphael95.github.io/output</id>
    <title>blog</title>
    <updated>2019-05-28T11:50:22.004Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://raphael95.github.io/output"/>
    <link rel="self" href="https://raphael95.github.io/output/atom.xml"/>
    <subtitle>æ¸©æ•…è€ŒçŸ¥æ–°</subtitle>
    <logo>https://raphael95.github.io/output/images/avatar.png</logo>
    <icon>https://raphael95.github.io/output/favicon.ico</icon>
    <rights>All rights reserved 2019, blog</rights>
    <entry>
        <title type="html"><![CDATA[Sorting  Algorithms]]></title>
        <id>https://raphael95.github.io/output/post/sort-algorithms</id>
        <link href="https://raphael95.github.io/output/post/sort-algorithms">
        </link>
        <updated>2019-05-27T15:03:27.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ“’ğŸ“ğŸ““ record seven sort algorithms.</p>
<p>they are: bubble sort ã€selection sortã€insertion sortã€quick sort ã€heap sortã€merge sortã€counting sort</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ“’ğŸ“ğŸ““ record seven sort algorithms.</p>
<p>they are: bubble sort ã€selection sortã€insertion sortã€quick sort ã€heap sortã€merge sortã€counting sort</p>
<!-- more -->
<h2 id="introduction">Introduction</h2>
<p>Some algorithms(<strong><a href="#selection">selection</a>, <a href="#bubble">bubble</a>, <a href="#heap">heap</a></strong>) work by moving elements to their final position, one at a time. You sort an array of size N, put 1 item in place and continue sorting and array of size N -1,</p>
<p>Some algorithms(<strong><a href="#insertion">insertion</a>, <a href="#quicksort">quicksort</a>, <a href="#counting">counting</a></strong>)put items to temporary place, closer to their final position, moving them closer to final position ,in each iteration.</p>
<p>Some algorithms(<strong><a href="#merge">merge</a></strong>) start with a 'sorted list ' of one element, and merge unsorted items into it, one at a time</p>
<h3 id="note">note</h3>
<ul>
<li>assume we are sorting a list or array of N elements</li>
<li>once sorted, smaller items are on the left, and larger items are on the right</li>
</ul>
<h3 id="span-idbubblebubble-sortspan"><strong><span id="bubble">Bubble Sort</span></strong></h3>
<blockquote>
<p>best: O(N), worst: O(N^2)</p>
</blockquote>
<p>Â Â starting on the left, compare adjacent items and keep 'bubbling' the the larger one to the right(it's in its final place), bubble sort the remaining N -1 items.</p>
<p>Â Â in each iteration, it will find the largest one in the rest of an array, and place it in the right.</p>
<p>pseudocode in C language:</p>
<pre><code>void bubble_sort(int *a, int len){
	int tmp;
	for(int i = 0; i &lt; len; i ++){
		for(int j = 0; j &lt; len - i - 1; i ++){
			if(a[j] &gt; a[j + 1]){
				tmp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = tmp;
			}
		}
	}
}
</code></pre>
<h3 id="span-idselectionselection-sortspan"><strong><span id="selection">Selection Sort</span></strong></h3>
<blockquote>
<p>best/worst: O(N^2)</p>
</blockquote>
<p>Â Â scan all items and find the smallest. Swap it into the position as the first item. Repeat the selection sort on the remaining N - 1 items</p>
<p>Â Â it just like the bubble sort, the outer iteration from 0 to N - 1ï¼Œ the inner iteration is to find the minimun item, and always swap it with i.</p>
<pre><code>void selection_sort(int *a, int len){
	int min, index, tmp;
	for(int i = 0; i &lt; len; i ++){
		min= a[i];
		for(int j = i; j &lt; len; j ++){
			if(a[j] &lt; min){
				min = a[j];
				index = j;
			}
			tmp = a[i];
			a[i] = a[index];
			a[index] = tmp;
		}
	}
}
</code></pre>
<h3 id="span-idinsertioninsertion-sortspan"><strong><span id="insertion">Insertion Sort</span></strong></h3>
<blockquote>
<p>best: O(N)ï¼Œ worst: O(N^2)</p>
</blockquote>
<p>Â Â start with a sorted list of 1 element on the left, and N - 1 unsorted items on the right. Taking the first unsorted item (element #2) and insert it into the sorted list, moving elements as neccesary. We now have a sorted list of size 2, and N -2 unsorted items, repeat for all items.</p>
<pre><code>void insertion_sort(int *a, int len){
	int min;
	for(int i = 0; i &lt; len; i ++){
		int j = i;
		min = a[i];
		while(j &gt; 0 &amp;&amp; a[j - 1] &gt; min){
			a[j] = a[j - 1];
			j = j - 1;
		}
		a[j] = min;
	}
}
</code></pre>
<h3 id="span-idquicksortquick-sortspan"><strong><span id="quicksort">Quick Sort</span></strong></h3>
<blockquote>
<p>best: O(N * lgN), avg: O(N * lgN), worst: O(N^2)</p>
</blockquote>
<p>there are many versions of QuickSort, which is one of the most popular sorting methods due to its speed O(N * lgN) average, but O(N^2) worst cae, here's a few:</p>
<ul>
<li>pick a 'pivot' item</li>
<li>partition the other items by adding them to a 'less than pivot' sublist, and 'larger than pivot' sublist</li>
<li>the pivot goes between the two sublists</li>
<li>repeat the quicksort on the two sublists until you get to a sublist of size 1(which is sorted)</li>
</ul>
<p><strong>the most important in  QuickSort is partition function</strong></p>
<pre><code>int partition(int *a, int low, int high){
	int pivot = a[i];
	int i = low;
	int j = high;
	while(i &lt; j){
		while(j &gt; i &amp;&amp; a[j] &gt;= pivot)
			j --;
		if(j &gt; i)
			a[i] = a[j];
		while(i &lt; j &amp;&amp; a[i] &lt;=pivot)
			i ++;
		if(i &lt; j)
			a[j] = a[i];
	}
	a[i] = pivot;
	return i;
}

int quick_sort(int *a, int i, int j){
	if(i &lt; j){
		int pivot = partition(a, i, j);
		quick_sort(a, i, pivot - 1);
		quick_sort(a, pivot + 1, j);
</code></pre>
<p>however, the algorithms in the partition above has a defects, the time complexity can be O(N^2), we will elaborate how it happens now. <strong>If a bad pivot is chosen, you can imagine that the 'less than pivot' sublist is always empty, that means  we are only creating a sublist of one item smaller each time, which gives us O(N^2)behavior in the worst case. If you choose the first item, it may be the smallest item in the sorted list and give worst-case behavior. <font color=red>You can choose a random item, or median-of three(front,middle,rear)</font>.</strong></p>
<p>an improved partition function in QuickSort :</p>
<pre><code>void compare(int *a, int *b){
	if(*a &gt; *b){
		int tmp;
		tmp = *a;
		*a = *b;
		*b = tmp;
	}
}

void swap(int *a, int *b){
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

void partition(int *a, int low, int high){
	int i = low;
	int j = high;
	int middle = (i + j) / 2;
	compare(&amp;a[i], &amp;a[middle]);
	compare(&amp;a[i], &amp;a[j]);
	compare(&amp;a[middle], &amp;a[j]);
	swap(&amp;a[i], &amp;a[middle]);
	int picot = a[i];
	while(i &lt; j){
		while(j &gt; i &amp;&amp; a[j] &gt;= picot)
			j --;
		if(j &gt; i)
			a[i] = a[j];
		while(i &lt; j &amp;&amp; a[i] &lt;=pivot)
			i ++;
		if(i &lt; j)
			a[j] = a[i];
		}
	a[i] = pivot;
	return i;
}
</code></pre>
<h3 id="span-idmergemerge-sortspan"><strong><span id="merge">Merge Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N * lgN)</p>
</blockquote>
<p>Merge sort is a divid-and-conquer algorithm based on the idea of breaking down a list into several sublists until each sublists consists of a single element and merging those sublists to a sorted list.</p>
<ul>
<li>divide the unsorted lists into N sublists, each containing 1 element.</li>
<li>take adjacent pair of two singleton lists and merge them to from a list of 2 elements, N will now convert into N / 2 lists of size 2.</li>
<li>repeat the process till a single sorted lists of obtained.</li>
</ul>
<pre><code>void merge(int *a, int low, int middle, int high){
	int left_low = low;
	int left_high = middle;
	int right_low = middle + 1;
	int right_high = high;
	int k = 0;
	int *tmp = (int *)malloc(sizeof(int) * (high - low + 1));
	for(k &lt; high; left_low &lt; left_high &amp;&amp; right_low &lt; right_high; k ++){
		if(a[left_low] &lt; a[right_low])
			tmp[k] = a[left_low ++];
		else
			tmp[k] = a[right_low ++];
	}
	if(left_low &lt; left_high){
		for(int i = left_low; i &lt; left_high; i ++)
			tmp[k ++] = a[i];
	if(right_low &lt; right_high){
		for(int i = right_low; i &lt; right_low; i ++)
			tmp[k ++] = a[i];
	
	for(int i = 0; i &lt; high - low + 1; i ++)
		a[low + i] = tmp[i];
	
	free(tmp);
}

void merge_sort(int *a, int low, int high){
	if(low &lt; high){
		int middle = (low + high) / 2;
		merge_sort(a, low, middle);
		merge_sort(a, middle + 1, high);
		merge(a, low, middle, high);
	}
}
	
</code></pre>
<h3 id="span-idheapheap-sortspan"><strong><span id="heap">Heap Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N * lgN)</p>
</blockquote>
<p>Heaps can be used in sorting an array, in max-heaps, maximum element will always be at the root, Heap sort uses this property of heap to sort the array. Adding all items into a heap, Pop the largest item from the heap and insert it at the end(final position), and repeat for all items.</p>
<p><strong>time complexity analysis</strong>:</p>
<p><font color=red>Creating the heap needs O(N * lgN).Poping items from heap is O(1), and adjust the heap after pop needs O(lgN), there are N pops, so there is another O(N * lgN) factor, which is O(N * lgN) overall.</font></p>
<p><font color=blue>Heap sort has O(N * lgN) behavior, even in the worst case, making it good for real-time applications.</font></p>
<pre><code>void adjust_heap(int *a, int root, int len){
	int left_child = 2 * root + 1;
	int right_child = 2 * root + 2;
	int max_child;
	if(left_child &gt;= size)
		return;
	else{
		if(righ_child &gt;= size)
			max_child = left_child;
		else
			max_child = a[left_child] &gt; a[right_child]? left_child, right_child;
		if(a[root] &lt; a[max_child]){
			int tmp = a[root];
			a[root] = a[max_child];
			a[max_child] = tmp;
			adjust_heap(a, max_child, len);
		}
	}
}

void build_heap(int *a, int len){
	for(int i = len / 2 - 1; i &gt;=0; i --)
		adjust_heap(a, i, len);
}

void heap_sort(int *a, int len){
	build_heap(a, len);
	for(int i = len - 1; i &gt;=0; i ++){
		int tmp = a[0];
		a[0] = a[i];
		a[i] = tmp;
		adjust_heap(a, 0, i);
	}
}
</code></pre>
<h3 id="span-idcountingcounting-sortspan"><strong><span id="counting">Counting Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N)</p>
</blockquote>
<p>Assuming the data are integers, in a range of 0-K. Creating an array of size K to keep track of how many items appears(3 items with value 0, 4 items with value 1, etc.). Given this count, you can tell the position of an item â€”â€” all the 1's must come after the 0's, of which these are 3. Therefore, the 1's start at item #4. Thus, we can scan the items and insert them into their proper position. <font color=red>In Counting Sort, the frequencies of distincts of the array to be sorted is counted and stored in an auxiliary array, by mapping its as value of the auxiliary array.</font></p>
<ul>
<li>Creating the auxiliary array is O(N)</li>
<li>Inserting items into their proper position needs O(N)</li>
</ul>
<pre><code>void counting_sort(int *a, int len){
	// find the maximum value
	int i;
	int max = 0;
	for(i = 0; i &lt; len; i ++){
		if(a[i] &gt; max)
			max = a[i];
	
	// initialize auxiliary array 
	int auxiliary[max];
	for(i=0; i &lt; max; i ++)
		auxiliary[i] = 0;
	
	for(i = 0; i &lt; len; i ++)
		auxiliary[a[i]] ++;
	
	int sorted_a[len];
	int j = 0;
	for(i = 0; i &lt;= max; i ++){
		counts = auxiliary[i];
		while(count --){
			sorted_a[j] = i;
			j ++;
		}
	}
	
	for(i = 0; i &lt; len; i ++){
		a[i] = auxiliary[i];
}
	
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://raphael95.github.io/output/post/hello-gridea</id>
        <link href="https://raphael95.github.io/output/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>ğ–¶ğ—‚ğ—‡ğ–½ğ—ˆğ—ğ—Œ</strong> æˆ– <strong>ğ–¬ğ–ºğ–¼ğ–®ğ–²</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>