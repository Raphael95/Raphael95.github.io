
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Sorting  Algorithms | blog</title>
<meta name="description" content="Ê∏©ÊïÖËÄåÁü•Êñ∞">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://raphael95.github.io/output/favicon.ico?v=1559803776143">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://raphael95.github.io/output/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://raphael95.github.io/output">
        <img class="avatar" src="https://raphael95.github.io/output/images/avatar.png?v=1559803776143" alt="" width="32px" height="32px">
      </a>
      <a href="https://raphael95.github.io/output">
        <h1 class="site-title">blog</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/output" class="menu purple-link">
            È¶ñÈ°µ
          </a>
        
      
        
          <a href="/output/archives" class="menu purple-link">
            Á¨îËÆ∞
          </a>
        
      
        
          <a href="/output/tags" class="menu purple-link">
            Ê†áÁ≠æ
          </a>
        
      
        
          <a href="/output/post/about" class="menu purple-link">
            ÂÖ≥‰∫é
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://www.beginnersbook.in/wp-content/uploads/2018/05/Sorting-Algorithm.png')">
            </div>
          
          <h2 class="post-title">Sorting  Algorithms</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2019-05-27</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://raphael95.github.io/output/tag/8pCHzlr4K">
                    sort
                    
                      Ôºå
                    
                  </a>
                
                  <a href="https://raphael95.github.io/output/tag/BVUYBZ85j">
                    algorithms
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p>üìíüìùüìì record seven sort algorithms.</p>
<p>they are: bubble sort „ÄÅselection sort„ÄÅinsertion sort„ÄÅquick sort „ÄÅheap sort„ÄÅmerge sort„ÄÅcounting sort</p>
<!-- more -->
<h2 id="introduction">Introduction</h2>
<p>Some algorithms(<strong><a href="#selection">selection</a>, <a href="#bubble">bubble</a>, <a href="#heap">heap</a></strong>) work by moving elements to their final position, one at a time. You sort an array of size N, put 1 item in place and continue sorting and array of size N -1,</p>
<p>Some algorithms(<strong><a href="#insertion">insertion</a>, <a href="#quicksort">quicksort</a>, <a href="#counting">counting</a></strong>)put items to temporary place, closer to their final position, moving them closer to final position ,in each iteration.</p>
<p>Some algorithms(<strong><a href="#merge">merge</a></strong>) start with a 'sorted list ' of one element, and merge unsorted items into it, one at a time</p>
<h3 id="note">note</h3>
<ul>
<li>assume we are sorting a list or array of N elements</li>
<li>once sorted, smaller items are on the left, and larger items are on the right</li>
</ul>
<h3 id="span-idbubblebubble-sortspan"><strong><span id="bubble">Bubble Sort</span></strong></h3>
<blockquote>
<p>best: O(N), worst: O(N^2)</p>
</blockquote>
<p>¬†¬†starting on the left, compare adjacent items and keep 'bubbling' the the larger one to the right(it's in its final place), bubble sort the remaining N -1 items.</p>
<p>¬†¬†in each iteration, it will find the largest one in the rest of an array, and place it in the right.</p>
<p>pseudocode in C language:</p>
<pre><code>void bubble_sort(int *a, int len){
	int tmp;
	for(int i = 0; i &lt; len; i ++){
		for(int j = 0; j &lt; len - i - 1; i ++){
			if(a[j] &gt; a[j + 1]){
				tmp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = tmp;
			}
		}
	}
}
</code></pre>
<h3 id="span-idselectionselection-sortspan"><strong><span id="selection">Selection Sort</span></strong></h3>
<blockquote>
<p>best/worst: O(N^2)</p>
</blockquote>
<p>¬†¬†scan all items and find the smallest. Swap it into the position as the first item. Repeat the selection sort on the remaining N - 1 items</p>
<p>¬†¬†it just like the bubble sort, the outer iteration from 0 to N - 1Ôºå the inner iteration is to find the minimun item, and always swap it with i.</p>
<pre><code>void selection_sort(int *a, int len){
	int min, index, tmp;
	for(int i = 0; i &lt; len; i ++){
		min= a[i];
		for(int j = i; j &lt; len; j ++){
			if(a[j] &lt; min){
				min = a[j];
				index = j;
			}
			tmp = a[i];
			a[i] = a[index];
			a[index] = tmp;
		}
	}
}
</code></pre>
<h3 id="span-idinsertioninsertion-sortspan"><strong><span id="insertion">Insertion Sort</span></strong></h3>
<blockquote>
<p>best: O(N)Ôºå worst: O(N^2)</p>
</blockquote>
<p>¬†¬†start with a sorted list of 1 element on the left, and N - 1 unsorted items on the right. Taking the first unsorted item (element #2) and insert it into the sorted list, moving elements as neccesary. We now have a sorted list of size 2, and N -2 unsorted items, repeat for all items.</p>
<pre><code>void insertion_sort(int *a, int len){
	int min;
	for(int i = 0; i &lt; len; i ++){
		int j = i;
		min = a[i];
		while(j &gt; 0 &amp;&amp; a[j - 1] &gt; min){
			a[j] = a[j - 1];
			j = j - 1;
		}
		a[j] = min;
	}
}
</code></pre>
<h3 id="span-idquicksortquick-sortspan"><strong><span id="quicksort">Quick Sort</span></strong></h3>
<blockquote>
<p>best: O(N * lgN), avg: O(N * lgN), worst: O(N^2)</p>
</blockquote>
<p>there are many versions of QuickSort, which is one of the most popular sorting methods due to its speed O(N * lgN) average, but O(N^2) worst cae, here's a few:</p>
<ul>
<li>pick a 'pivot' item</li>
<li>partition the other items by adding them to a 'less than pivot' sublist, and 'larger than pivot' sublist</li>
<li>the pivot goes between the two sublists</li>
<li>repeat the quicksort on the two sublists until you get to a sublist of size 1(which is sorted)</li>
</ul>
<p><strong>the most important in  QuickSort is partition function</strong></p>
<pre><code>int partition(int *a, int low, int high){
	int pivot = a[i];
	int i = low;
	int j = high;
	while(i &lt; j){
		while(j &gt; i &amp;&amp; a[j] &gt;= pivot)
			j --;
		if(j &gt; i)
			a[i] = a[j];
		while(i &lt; j &amp;&amp; a[i] &lt;=pivot)
			i ++;
		if(i &lt; j)
			a[j] = a[i];
	}
	a[i] = pivot;
	return i;
}

int quick_sort(int *a, int i, int j){
	if(i &lt; j){
		int pivot = partition(a, i, j);
		quick_sort(a, i, pivot - 1);
		quick_sort(a, pivot + 1, j);
</code></pre>
<p>however, the algorithms in the partition above has a defects, the time complexity can be O(N^2), we will elaborate how it happens now. <strong>If a bad pivot is chosen, you can imagine that the 'less than pivot' sublist is always empty, that means  we are only creating a sublist of one item smaller each time, which gives us O(N^2)behavior in the worst case. If you choose the first item, it may be the smallest item in the sorted list and give worst-case behavior. <font color=red>You can choose a random item, or median-of three(front,middle,rear)</font>.</strong></p>
<p>an improved partition function in QuickSort :</p>
<pre><code>void compare(int *a, int *b){
	if(*a &gt; *b){
		int tmp;
		tmp = *a;
		*a = *b;
		*b = tmp;
	}
}

void swap(int *a, int *b){
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

void partition(int *a, int low, int high){
	int i = low;
	int j = high;
	int middle = (i + j) / 2;
	compare(&amp;a[i], &amp;a[middle]);
	compare(&amp;a[i], &amp;a[j]);
	compare(&amp;a[middle], &amp;a[j]);
	swap(&amp;a[i], &amp;a[middle]);
	int picot = a[i];
	while(i &lt; j){
		while(j &gt; i &amp;&amp; a[j] &gt;= picot)
			j --;
		if(j &gt; i)
			a[i] = a[j];
		while(i &lt; j &amp;&amp; a[i] &lt;=pivot)
			i ++;
		if(i &lt; j)
			a[j] = a[i];
		}
	a[i] = pivot;
	return i;
}
</code></pre>
<h3 id="span-idmergemerge-sortspan"><strong><span id="merge">Merge Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N * lgN)</p>
</blockquote>
<p>Merge sort is a divid-and-conquer algorithm based on the idea of breaking down a list into several sublists until each sublists consists of a single element and merging those sublists to a sorted list.</p>
<ul>
<li>divide the unsorted lists into N sublists, each containing 1 element.</li>
<li>take adjacent pair of two singleton lists and merge them to from a list of 2 elements, N will now convert into N / 2 lists of size 2.</li>
<li>repeat the process till a single sorted lists of obtained.</li>
</ul>
<pre><code>void merge(int *a, int low, int middle, int high){
	int left_low = low;
	int left_high = middle;
	int right_low = middle + 1;
	int right_high = high;
	int k = 0;
	int *tmp = (int *)malloc(sizeof(int) * (high - low + 1));
	for(k &lt; high; left_low &lt; left_high &amp;&amp; right_low &lt; right_high; k ++){
		if(a[left_low] &lt; a[right_low])
			tmp[k] = a[left_low ++];
		else
			tmp[k] = a[right_low ++];
	}
	if(left_low &lt; left_high){
		for(int i = left_low; i &lt; left_high; i ++)
			tmp[k ++] = a[i];
	if(right_low &lt; right_high){
		for(int i = right_low; i &lt; right_low; i ++)
			tmp[k ++] = a[i];
	
	for(int i = 0; i &lt; high - low + 1; i ++)
		a[low + i] = tmp[i];
	
	free(tmp);
}

void merge_sort(int *a, int low, int high){
	if(low &lt; high){
		int middle = (low + high) / 2;
		merge_sort(a, low, middle);
		merge_sort(a, middle + 1, high);
		merge(a, low, middle, high);
	}
}
	
</code></pre>
<h3 id="span-idheapheap-sortspan"><strong><span id="heap">Heap Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N * lgN)</p>
</blockquote>
<p>Heaps can be used in sorting an array, in max-heaps, maximum element will always be at the root, Heap sort uses this property of heap to sort the array. Adding all items into a heap, Pop the largest item from the heap and insert it at the end(final position), and repeat for all items.</p>
<p><strong>time complexity analysis</strong>:</p>
<p><font color=red>Creating the heap needs O(N * lgN).Poping items from heap is O(1), and adjust the heap after pop needs O(lgN), there are N pops, so there is another O(N * lgN) factor, which is O(N * lgN) overall.</font></p>
<p><font color=blue>Heap sort has O(N * lgN) behavior, even in the worst case, making it good for real-time applications.</font></p>
<pre><code>void adjust_heap(int *a, int root, int len){
	int left_child = 2 * root + 1;
	int right_child = 2 * root + 2;
	int max_child;
	if(left_child &gt;= size)
		return;
	else{
		if(righ_child &gt;= size)
			max_child = left_child;
		else
			max_child = a[left_child] &gt; a[right_child]? left_child, right_child;
		if(a[root] &lt; a[max_child]){
			int tmp = a[root];
			a[root] = a[max_child];
			a[max_child] = tmp;
			adjust_heap(a, max_child, len);
		}
	}
}

void build_heap(int *a, int len){
	for(int i = len / 2 - 1; i &gt;=0; i --)
		adjust_heap(a, i, len);
}

void heap_sort(int *a, int len){
	build_heap(a, len);
	for(int i = len - 1; i &gt;=0; i ++){
		int tmp = a[0];
		a[0] = a[i];
		a[i] = tmp;
		adjust_heap(a, 0, i);
	}
}
</code></pre>
<h3 id="span-idcountingcounting-sortspan"><strong><span id="counting">Counting Sort</span></strong></h3>
<blockquote>
<p>best/avg/worst: O(N)</p>
</blockquote>
<p>Assuming the data are integers, in a range of 0-K. Creating an array of size K to keep track of how many items appears(3 items with value 0, 4 items with value 1, etc.). Given this count, you can tell the position of an item ‚Äî‚Äî all the 1's must come after the 0's, of which these are 3. Therefore, the 1's start at item #4. Thus, we can scan the items and insert them into their proper position. <font color=red>In Counting Sort, the frequencies of distincts of the array to be sorted is counted and stored in an auxiliary array, by mapping its as value of the auxiliary array.</font></p>
<ul>
<li>Creating the auxiliary array is O(N)</li>
<li>Inserting items into their proper position needs O(N)</li>
</ul>
<pre><code>void counting_sort(int *a, int len){
	// find the maximum value
	int i;
	int max = 0;
	for(i = 0; i &lt; len; i ++){
		if(a[i] &gt; max)
			max = a[i];
	
	// initialize auxiliary array 
	int auxiliary[max];
	for(i=0; i &lt; max; i ++)
		auxiliary[i] = 0;
	
	for(i = 0; i &lt; len; i ++)
		auxiliary[a[i]] ++;
	
	int sorted_a[len];
	int j = 0;
	for(i = 0; i &lt;= max; i ++){
		counts = auxiliary[i];
		while(count --){
			sorted_a[j] = i;
			j ++;
		}
	}
	
	for(i = 0; i &lt; len; i ++){
		a[i] = auxiliary[i];
}
	
</code></pre>

          </div>
        </div>

        
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">Ê∏©ÊïÖËÄåÁü•Êñ∞</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://raphael95.github.io/output/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'd428067266924907dc0b',
        clientSecret: '0f925e73ae19595836304e7a7029fefa70e5222e',
        repo: 'Raphael95.github.io',
        owner: 'Raphael95',
        admin: ['Raphael95'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
